# Шпаргалка по Git

### Основы
------------------------------------------------------------------------------------------------------------------------------
* `ctrl + ~` - вызов терминала в VS Code.
* `git init` - создаёт git репозиторий (скрытую папку .git) в той директории из которой была вызвана данная команда.
* `git add file` - индексирует(подготавливает) file к коммиту.
* `git commit -m 'описание коммита'` - коммитит(сохраняет состояние) проиндексированных файлов.

#### Индексация и коммит файлов
* `git add *` - выбирает ВСЕ файлы для индексации, даже те которые не изменились.
* `git add .`, или `git add --all`, или `git add -A` - выбирает ВСЕ файлы: изменённые, удалённые и новые.
* `git add -u` - выбирает ВСЕ файлы для индексации, кроме новых.
* `git add --no--all .` - выбирает ВСЕ файлы кроме удалённых (без точки в конце(пути), команда не срабатывает).
* `git add -f` - выбирает и индексирует ВСЕ файлы даже игнорируемые.

* `.` - путь, обозначающий текущую директорию, т.е. ту в которой запущена команда.
* `:/` - путь, обозначающий рабочую директорию, т.е. ту в которой находится директория .git
Используя `:/` можно индексировать файлы рабочей директории, находять при этом во вложенных директориях.  

Индексацию файлов и коммит можно объединить в одну команду:  
 `git commit file-name -m 'commit description'`  
Чтобы проиндексировать и закомиттить ВСЕ файлы сразу, можно использовать следующую команду:  
 `git commit -am 'commit description'`  

Отменить индексацию файла:  
 `git rm --cached file`  

Git не отслеживает пустые директории, поэтому их нельзя добавить в индекс.  
Git позволяет очистить рабочую директорию удалив все пустые директории и новые файлы:  
 `git clean -fd` - `-f`(force), `-d`(directory)  
При этом данная команда не затрагивает модифицированные или проиндексированные файлы.  

#### Работа с ветками
------------------------------------------------------------------------------------------------------------------------------
Переключится на ветку my-branch:  
 `git checkout my-branch` или `git switch my-branch`  

Создать и переключиться на ветку my-branch:  
 `git checkout -b my-branch` или `git switch -c my-branch`  
Команда `git checkout` обладает более расширенным функционалом, `switch` просто переключает ветки.  

Создание новой ветки из прошлого коммита, например из коммита с хэшем `123abc4`:  
 `git checkout -b new-branch(имя новой ветки) 123abc4(хэш с которого пойдёт ответвление)`  

Создание новой ветки из текущего коммита создаётся без указания хэша, ветвление пойдёт с текущего коммита:  
 `git checkout -b new-branch`  

Переименование ветки:  
 `git branch -m старое-имя-ветки новое-имя-ветки`  


### Создание удалённого git репозитория
------------------------------------------------------------------------------------------------------------------------------
Для существующего локального проекта.  
1. В существующем проекте инициируем Git (если это ещё не было сделано), индексируем необходимые файлы и коммитим.
2. Создаем репозиторий на Гитхабе для существующего проекта.
3. Копируем ссылку с GitHub (в данном случае SSH ссылку) на удаленный репозиторий, и указываем её в команде:  
   `git remote add origin git@github.com:Ciberian/test-project.git`
4. После этого пушим в мастер ветку удаленного репозитория, наш проект командой:  
   `git push -u origin master` (-u ключ используется только при первом пуше, для связи локальной и удаленной веток.)
5. * В дальнейшем можно использовать упрощённую команду `git push` - для ветки `master`.
   * Если мы работали в другой ветке, то команда `git push origin another-branch` - для ветки `another-branch`.  
Если мы не напишем название ветки, то Git по умолчанию отправит все изменения в ветку `master`.

------------------------------------------------------------------------------------------------------------------------------
Для не существующего локального проекта.  
1. Создаем репозиторий на Гитхабе, или форкаем существующий проект на свой аккаунт.
2. Копируем SSH ссылку, нажав кнопку Code и выбрав SSH вариант.
3. Создаём на локальном ПК папку, в которой будет находиться будущий проект.
4. Открываем через GitBash эту папку (ПКМ).
5. Клонируем (скачиваем себе на ПК) созданный, или форкнутый репозиторий командой:  
   `git clone git@github.com:Ciberian/test-project.git .`  
   Точка в конце команды указывает текущую директорию, в которую будет скачан проект, но можно указать другой путь, если надо.

### Работа с pullrequest-ами
------------------------------------------------------------------------------------------------------------------------------
**Pullrequest-ы** делаются в интерфейсе ГитХаба, нажатием соответствующих кнопок.  
Если в код потребуется внести изменения, вам нужно снова пройти по цепочке локальные:  
**изменения — сохранение — коммит — пуш**, только пулреквест заново делать не нужно.  
Если вы продолжаете вести работу в той же ветке и пулреквест ещё не принят, все ваши изменения автоматически добавятся в пулреквест, 
созданный из этой ветки, после команды `git push origin название-текущей-ветки`.

Форк на **GitHub** не синхронизируется с оригиналом(мастер-репозиторием) автоматически, чтобы не возникало конфликтов и каждый разработчик мог сам решать, что делать со своим форком.  
Чтобы продолжить работу над проектом, нам нужно привести форк в актуальное состояние — получить попавшие в мастер-репозиторий изменения.  
Для начала добавим ссылку на мастер-репозиторий, чтобы нам было удобно к нему обращаться, а Git понимал, откуда именно мы хотим забрать изменения.  

1. В локальном репозитории вводим команду `git checkout master`, переходим в ветку **master**.

2. Заходим в мастер-репозиторий, копируем его SSH-адрес и вводим в терминале команду:  
 `git remote add alias git@github.com:htmlacademy-javascript/1332863-keksobooking-25.git`

В этой команде вам нужно подставить свои данные:  
**alias** — короткое имя (алиас) для репозитория. На курсах для обращения к мастер-репозиторию мы используем алиас **academy**, 
но вы можете выбрать любой другой: вместо academy указывайте своё название, и оно закрепится за этим репозиторием.  
_[git@github.com:htmlacademy-javascript/1332863-keksobooking-25.git]_ — путь к репозиторию (тот самый SSH-адрес, который вы копируете на странице репозитория)

3. Теперь можем забирать (подтягивать) изменения из ветки **master** мастер-репозитория командой не указывая каждый раз путь к репозиторию:  
 `git pull academy master`
После этого в ветке master локального форка появятся те же коммиты, что и в мастер-репозитории.  

4. Отправляем подтянутые из мастер-репозитория изменения в свой форк на GitHub с помощью команды:  
 `git push origin master`

### Дополнительная информация
------------------------------------------------------------------------------------------------------------------------------

Откат **файла** к состоянию в определённом коммите:  
 `git checkout commit-hash dir/file-name`
Откатывает только указанный файл, остальные остаются не изменными.   

Удаление файла из коммита и одновременно из папки проекта:  
 `git rm dir/file-name.css`  
Фиксируем удаление новым коммитом:  
 `git commit --amend --no-edit`  
Таким образом Гит не изменяет старый коммит, а создаёт новый и заменяет старый на новый.  

Удаление файла из коммита, но не удаление его из папки проекта:  
 `git rm --cached dir/file-name.css`  
Фиксируем удаление новым коммитом:  
 `git commit --amend --no-edit`  

Удаление последнего коммита:  
 `git reset --hard HEAD~`  
Флаг `--hard` означает полное удаление. Без него `git reset` отменит коммит, но не удалит его, а поместит все изменения этого коммита в рабочую директорию, так что с ними можно будет продолжить работать.  
`HEAD~` означает "один коммит от последнего коммита". Если бы мы хотели удалить два последних коммита, то могли бы написать `HEAD~2`.  

Небольшие изменения, которые присутствуют только на локальном ПК, можно досылать в последний коммит, а не создавать ради этого новый коммит.  
Для этого индексируем изменения и используем команду:  
 `git commit --amend`
Появится редактор, в котором можно изменить сообщение последнего коммита, или закрыть редактор и оставить старое сообщение.  
Для того, чтобы не открывался редактор для ввода описания коммита к команде git commit `--amend` можно добавить опцию `--no-edit`.  
В этом случае описание коммита не изменится.  

Вы написали сообщение коммита (commit message) с ошибкой. Как её исправить?  
У команды commit есть параметр amend, который позволяет изменить последний коммит:  
 `git commit --amend -m 'Правильное сообщение коммита'` 

История коммитов в одну строку:  
 `git log --oneline`  

История коммитов в виде графа, чтобы ориентироваться в ветках:  
 `git log --graph`  

Поиск в истории коммитов изменение конкретного файла:  
 `git log -p --oneline -- todo.md`  

Временно спрятать изменённые файлы вне зависимости от того проиндексированы они или нет:  
 `git stash`  

Вернуть изменённые файлы обратно:  
 `git stash pop`  

**Stash** в Git работает по принципу стека. Он позволяет сохранить внутрь любое количество изменений и восстановить их в обратном порядке.  
Чтобы спрятать новый файл, нужно его проиндексировать, иначе stash его не увидит.  

### Файл .gitignore
------------------------------------------------------------------------------------------------------------------------------
Git позволяет гибко настраивать игнорирование определенных файлов и директорий.   
Делается это с помощью файла **.gitignore**, который нужно создать в корне проекта:  
В этом файле можно оставлять комментарии с помощью знака \#  

Пример содержания данного файла:  
 
Игнорируется файл в любой директории проекта:  
`access.log`  

Игнорируется директория в любой директории проекта:  
`node_modules`  

Игнорируется каталог в корне рабочей директории:  
`/coverage`  

Игнорируются все файлы с расширением sqlite3 в директории db, но не игнорируются такие же файлы внутри любого вложенного каталога в db
например, /db/something/lala.sqlite3:  
`/db/*.sqlite3`  

Игнорируются все .txt файлы в каталоге doc/ на всех уровнях вложенности:  
`doc/**/*.txt`  

[Еще вариант .gitignore](https://github.com/Hexlet/hexlet-cv/blob/main/.gitignore)  

### Создание ssh-ключей
------------------------------------------------------------------------------------------------------------------------------
 `ssh-keygen -t rsa -b 4096 -C "your_email@example.com"`  
Дальше будет несколько вопросов. На все вопросы нужно нажимать Enter.  

Запуск агента ssh, который следит за ключами  
 `eval "$(ssh-agent -s)"`  

Добавления нового ssh-ключа в агент  
 `ssh-add ~/.ssh/id_rsa`  

Выведите содержимое файла ~/.ssh/id_rsa.pub и скопируйте его:  
 `cat ~/.ssh/id_rsa.pub`  

Добавьте ssh-ключ в аккаунт Github. При добавлении вас попросят назвать ключ. Напишите что-нибудь в стиле **home**.  

------------------------------------------------------------------------------------------------------------------------------